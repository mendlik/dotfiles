# Gotchas:
    # - Do not use tab characters to align functions.
    #   It blows up zsh autocompletion.
    # - Always check if alias is already used
    # - Use double indent for IDE folding
[alias]
    # Magic spells
        # Secure force push
        please=!git push --atomic --force-with-lease
    # Aliases
        # List all aliases
        aliases = "!f() { \
            git config --list | \
            grep 'alias\\.' | \
            sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1 => \\2/' | \
            sed 's|[[:space:]]\\+\\ *| |g' | \
            awk 'BEGIN { FS = \"=>\" } { printf(\"%-20s=>%s\\n\", $1, $2)}'; \
        }; f"
        # Open documentation
        aliases-doc = !sensible-browser 'https://github.com/mendlik/dotfiles/blob/master/git/readme.md' &
        # Find an alias
        alias = "!f() {\
            git aliases | grep \"^\\w*$1\\w*\"; \
        }; f"
        al = !git alias
    # Log
        # Shorter version
        lg = log
        # Pretty printed log
        log-pretty = log --pretty=custom
        lgp = !git log-pretty
        # Show pretty printed log with branch graph
        log-graph = log --graph --pretty=custom
        lgg = !git log-graph
        # Show pretty printed log with files
        log-files = log --pretty=custom --numstat --decorate --name-status
        lgf = !git log-files
        # Show pretty printed commit log with diffs.
        log-diff = log -M --stat --pretty=custom -p --color-words
        lgd = !git log-diff
        # Show pretty printed commit log with diffs for a single file.
        # Better than git blame. See: http://blog.andrewray.me/a-better-git-blame/
        log-blame = log -M --follow --stat --pretty=custom -p --color-words
        lgb = !git log-diff
    # Status
        # Shorter versions
        st = status
        # Short status
        status-short = status -s
        sts = !git status-short
        # Verbose status
        status-verbose = status -v
        stv = !git status-verbose
    # Fetch
        # Shorter version
        fe = fetch
        # Fetch master
        fetch-master = !git fetch $(git remotename) master
        fem = !git fetch-master
        # Fetch branch
        fetch-branch = "!f() { \
            git fetch $(git remotename) ${1:-$(git branchname)}; \
        }; f"
        feb = !git fetch-branch
    # Checkout
        # Shorter version
        co = checkout
        # Checkout master
        checkout-master = !git checkout master
        com = !git checkout-master
        # Checkout and pull changes
        checkout-synced = "!f() { \
            git checkout ${1:-master} && git pull; \
        }; f"
        cos = !git checkout-synced
    # Add
        # Shorter version
        ad = add
        # Add all
        add-all = add -A
        ada = !git add-all
    # Commit
        # Shorter version
        cm = commit
        # Commit all changes
        commit-all = !git add -A && git commit -av
        cma = !git commit-all
        # Autosquashed commits
        commit-fixup = !git add -A && git commit -av --fixup
        commit-squash = !git add -A && git commit -av --squash
    # Amend
        # Amend the currently staged files to the latest commit
        amend = commit --amend --no-edit
        an = !git amend
        # Amend all
        amend-all = !git add -A && git amend -a
        ana = !git amend-all
        # Change message of the last commit
        amend-author = "!f() { \
            local username=\"${1:-$(git username)}\"; \
            local email=\"${2:-$(git useremail)}\"; \
            git commit --amend --author \"${username} <${email}>\" --no-edit; \
        }; f"
        anu = !git amend-author
        # Change author of the last commit
        amend-message = "!f() { \
            git commit --amend --message \"$1\"; \
        }; f"
        anm = !git amend-message
    # Rebase
        # Shorter version
        re = rebase
        # Rebase with remote branch
        rebase-remote = "!f() { \
            git rebase $(git remotename)/${1:-$(git branchname)}; \
        }; f"
        rer = !git rebase-remote
        # Rebase with remote master
        rebase-remote-master = !git rebase $(git remotename)/master
        rerm = !git rebase-remote-master
    # Squash
        # Interactive rebase with a branch or a number of latest commits or branch
        squash = "!f() { git rebase -i ${1:-master}; }; f"
        sq = !git squash
        # Squash all commits available on the branch.
        squash-total = !git rebase -i --root
        sqt = !git squash-total
        # Squash all commits that are ahead of the upstream
        squash-ahead = !git rebase -i $(git rev-list --count --left-right @{upstream}...HEAD | cut -f2)
        sqa = !git squash-ahead
    # Tag
        # Shorter version
        tg = !git tag
        # Create tag with date
        create-tag = "!f() { \
            local tagname=\"$1\"; \
            local tagmessage=\"$2\"; \
            [ -z \"tagname\" ] && { (>&2 echo \"No tag name is specified\"); exit 1; }; \
            [ -z \"tagmessage\" ] && \
                git tag \"$tagname\" || \
                git tag -a \"$tagname\" -m \"$tagmessage\"; \
        }; f"
        # Create tag with date
        create-tag-date = "!f() { \
            git tag-new \"${1:+$1_}$(date \"+%Y-%m-%d\")\" \"$2\"; \
        }; f"
        # List all tags
        tags = !git tag
        tga = !git tags
        # List tags available on branch
        tags-branch = "!f() { \
            git tag --merged ${1:-$(git branchname)} | tac; \
        }; f"
        tgb = !tags-branch
        # Remove the old tag with this name and tag the latest commit with it.
        retag = "!f() { \
            local oldtagname=\"${2:-$(git lasttag)}\"; \
            local newtagname=\"${1:-$oldtagname}\"; \
            git tag -d $oldtagname && git tag $newtagname; \
        }; f"
        retag-globally = "!f() { \
            local oldtagname=\"${2:-$(git lasttag)}\"; \
            local newtagname=\"${1:-$oldtagname}\"; \
            git tag -d $oldtagname && \
                git tag $newtagname && \
                git push $remotename :refs/tags/$oldtagname && \
                git push $remotename ${1:-$newtagname}; \
        }; f"
        # Pushing tags
        push-tags = push --tags
        push-tag = "!f() { \
            git push ${2:-$(git remotename)} ${1:-$(git lasttag); \
        }; f"
        # Deleting tags
        delete-tag = "!f() { \
            git tag -d ${1:-$(git lasttag)}; \
        }; f"
        delete-tag-remotely = "!f() { \
            git push ${2:-$(git remotename)} :refs/tags/${1:-$(git lasttag)}; \
        }; f"
        delete-tag-globally = "!f() { \
            git delete-tag-locally $@ && \
                git delete-tag-remotely $@; \
        }; f"
    # Commit traversal
        prev-commit = !git checkout HEAD~
        next-commit = "!f() { \
            local hash=\"$(git currcommit)\"; \
            local child=\"$(\
                git rev-list --all --not \"HEAD\"^@ --children | \
                grep $hash | \
                cut -d' ' -f2- | \
                sed 's| |\\n|g' | \
                grep -v $hash \
            )\"; \
            local childrencount=\"$(echo \"$child\" | wc -l)\"; \
            if [ \"$childrencount\" -gt 1 ]; then \
                if [ ! -z "$1" ]; then \
                    child=\"$(git rev-list $1 | grep $hash -B 1 | head -n 1)\"; \
                else \
                    echo \"Found multiple children commits:\"; \
                    for c in $child; do \
                        echo \"  $c $(git log -s --format=%s -n 1 $c)\"; \
                    done; \
                    echo \"\\nOptions:\"; \
                    echo \"- Pick one child commit and do: git checkout COMMIT\"; \
                    echo \"- Pick a branch and execute: git nextcommit BRANCH\"; \
                    echo \"\\nAvailable branches:\"; \
                    git branch --contains $(git currcommit); \
                    exit 1; \
                fi; \
            fi; \
            [ ! -z \"$child\" ] && \
                git checkout $child || \
                git checkout $(git branch -a --contains $hash | grep -v HEAD | head -n 1); \
        }; f"
        prev-tag = !git checkout $(git lasttag)
        next-tag = "!f() { \
            local tagname=\"\"; \
            local nexttags=\"$(git tag -l --contains $(git currcommit))\"; \
            local nextcommitresult=0; \
            while [ -z \"$tagname\" ] && [ ! -z \"$nexttags\" ] && [ $nextcommitresult -eq 0 ]; do \
                git next-commit $@; \
                nextcommitresult=$?; \
                tagname=\"$(git describe --exact-match --tags --abbrev=0)\"; \
                nexttags=\"$(git tag -l --contains $(git currcommit))\"; \
            done; \
        }; f"
    # Diff
        # Shorter version
        df = diff
        # Shows the changes between the working directory and the index
        diff-work-index = diff --color-words
        dfwi = !git diff-work-index
        # Shows the changes between the index and the HEAD
        diff-index-head = !git diff --cached --color-words
        dfih = !git diff-index-head
        # Shows all the changes between the working directory and HEAD
        diff-work-head = !git diff HEAD --color-words
        dfwh = !git diff-head-work
        # Create a diff with binaries. Could be used with `git apply `
        diff-patch = !git diff HEAD --binary
        dfp = !git diff-patch
    # Undo actions
        # Undo staging
        unadd = !git reset HEAD --
        # Undo commit
        uncommit = !git reset --soft HEAD^
        # Undo to previous commit
        undo-prev-commit = !git reset HEAD^
        # Undo all local commits on current branch. Reset to the state of the upstream branch.
        undo-branch-local-commits = !git reset --soft $(git remotename)/$(git branchname)
        # Undo all branch commits that are ahead of source branch
        undo-branch-commit-range = "!f() { \
            local branchname=\"${1:-master}\"; \
            local n=\"$(git log --oneline ${branchname}..$(git branchname) | wc -l)\"; \
            git reset --soft HEAD~${n}; \
        }; f"
    # Drop changes
        # Drop all untracked files
        drop-unadded = !git clean -xf
        # Drop uncommitted changes
        drop-uncommitted = !git reset --hard && git clean -xf
        # Drop to previous commit. Drop a committed and uncommitted. Restore previous commit.
        drop-prev-commit = "!f() { \
            git reset --hard HEAD~${1:-1} && git clean -xf; \
        }; f"
        # Drop all committed and ucommitted changes made on the branch. Restore branch to inital state.
        drop-branch-local-changes = !git reset --hard $(git remotename)/$(git branchname) && git clean -xf
        drop-branch-change-range = "!f() { \
            local branchname=\"${1:-master}\"; \
            local n=\"$(git log --oneline ${branchname}..$(git branchname) | wc -l)\"; \
            git reset --hard HEAD~${n} && git clean -xf; \
        }; f"
    # Reflog
        # Shorter version
        rl = !git reflog
        # Pretty printed reflog
        reflog-pretty = reflog --pretty=customreflog
        rlp = !git reflog-pretty
    # Find
        # Customized alias for grep
        find-file = grep -Iin
        fnf = !git find-file
        # Find branches containing commit
        find-branch-by-hash = "!f() { \
            for h in $(git expandhash $1); do \
                echo \"Commit: $h\"; \
                git branch -a --contains $h; \
            done; \
        }; f"
        # Find tags containing commit
        find-tag-by-hash = "!f() { \
            for h in $(git expandhash $1); do \
                echo \"Commit: $h\"; \
                git describe --always --contains $h; \
            done; \
        }; f"
        # Find commits by content
        find-commit-by-content = "!f() { \
            git log --pretty=custom --decorate -S$1 -i; \
        }; f"
        fnc = !git findcommit
        # Find commits by commit message
        find-commit-by-msg = "!f() { \
            git log --pretty=custom --decorate --grep=\"$1\" -i; \
        }; f"
        fncm = !git findcommitbymsg
        # Find commits by short hash
        find-commit-by-hash = "!f() { \
            for h in $(git expandhash $1); do \
                echo \"Commit: $h\"; \
                git log -p -1 $h; \
            done; \
        }; f"
        fnch = !git findcommitbymsg
    # Contribution TODO
        contributors = git log --all --format='%<(20)%aN <%cE>' | sort -u
    # Remote
        # List remotes
        remotes = remote -v
        # Internal usage
        remotename = "!f() { \
            local remotename=\"$(git remote show)\"; \
            [ -z \"$remotename\" ] && { \
                (>&2 echo \"No remote is specified\"); \
                exit 1; \
            }; \
            echo $remotename; \
        }; f"
    # Branch
        # List branches
        branches = branch -a
        # Show branch name
        branchname = !git symbolic-ref --short HEAD
        # New branch
        create-branch = !git checkout -b
        # Dropping branches
        delete-branch="!f() { \
            local branch=\"${1:-$(git branchname)}\"; \
            [ \"$branch\" = \"$(git branchname)\" ] && git checkout master; \
            git branch -D $branch; \
        }; f"
        delete-branch-remotely="!f() { \
            local branchname=\"${1:-$(git branchname)}\"; \
            git push ${2:-$(git remotename)} --delete $branchname; \
            git branch --unset-upstream $branchname; \
        }; f"
        delete-branch-globally="!f() { \
            git droplocalbranch $@ && git dropremotebranch $@; \
        }; f"
    # Github aliases
        github-fetch-pr = "!sh -c 'git fetch $(git remotename) pull/$0/head:pr/$0'"
        github-pr = "!sh -c 'git fetch $(git remotename) pull/$0/head:pr/$0 && git checkout pr/$0 && git pull'"
    # Other
        # Just shorter
        cl = clone
        cp = cherry-pick
        # User info
        username = !git config --get user.name
        useremail = !git config --get user.email
        user = "!f() { echo \"$(git username) <$(git useremail)>\"; }; f"
        # Show current commit hash
        currcommit = !git rev-parse "HEAD"
        # Expand commit hash
        expandhash = "!f() { \
            git log --pretty=format:'%H' | \
            grep \"^$1\"; \
        }; f"
        # Find hash for commit message
        hashformsg = "!f() { \
            git log --pretty='%H %s' | \
            grep -i \"${1:-$(git currcommit)}\" | \
            cut -d ' ' -f1; \
        }; f"
        # Show last tag available on branch
        lasttag = "!f() { \
            [ $(git branchname) ] && \
                git describe --abbrev=0 --tag || \
                git describe --abbrev=0 --tag `git describe --abbrev=0 --tag`^; \
        }; f"
        # Show what is going on origin branches
        show-origin = "!sh -c 'git fetch && for branch in `git branch -r | grep -v HEAD`;do echo `git show -s --format=custom $branch | head -n 1` \\\t$branch; done | sort -r'"
        # Initialize git repo
        start = !git init && git add . && git commit --allow-empty -am \"Initial commit\"
        # Fix .gitignore
        fix-gitignore = !git rm -r --cached . && git add . && git commit -m \"Just a .gitignore fix \"
        # Jira tickets (from: http://blogs.atlassian.com/2014/08/whats-new-git-2-1/)
        show-issues = "!f() { : git log ; echo 'Printing issue keys'; git log --oneline $@ | egrep -o [A-Z]+-[0-9]+ | sort | uniq; }; f"
        # Check if any file in repo has whitespace errors
        # As described in http://peter.eisentraut.org/blog/2014/11/04/checking-whitespace-with-git/
        check-whitespaces = !git diff-tree --check $(git hash-object -t tree /dev/null) HEAD
        # Remove branches that have already been merged with master
        deletemergedbranches = "!git branch --merged | grep -v '\\*' | xargs -n 1 git branch -d"
