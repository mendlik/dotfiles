#!/bin/bash

# This prompt inspired by:
#   https://github.com/alrra/dotfiles/blob/master/shell/bash_prompt
#   https://github.com/paulirish/dotfiles/blob/master/.bash_prompt
#   https://github.com/mathiasbynens/dotfiles/blob/master/.bash_prompt

# Documentation:
#   http://www.thegeekstuff.com/2008/09/bash-shell-take-control-of-ps1-ps2-ps3-ps4-and-prompt_command/
#   http://askubuntu.com/questions/372849/what-does-debian-chrootdebian-chroot-do-in-my-terminal-prompt
#   http://misc.flogisoft.com/bash/tip_colors_and_formatting
#   http://wiki.bash-hackers.org/scripting/terminalcodes

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM=xterm-256color
fi

# Config
declare PROMPT_DEFAULT_USERHOST=""      # Add it to ~/.bash_exports_local
declare PROMPT_GIT_TIMEOUT="0.5s"       # Git status check timeout
declare PROMPT_TIMESTAMP="0"            # Add timestamp to prompt (date format)
declare -i PROMPT_NEWLINE=40            # Break command line after 40 characters (-1=never)
declare -i PROMPT_COLORS=1              # Use colors
declare -i PROMPT_STATUS=0              # Show last command result status
declare -i PROMPT_SIMPLE=0              # Fallback to simple prompt

function PROMPT_COMMAND() {
    local -r COLOR_RESET="\[\e[0m\]"
    local -r COLOR_RED="\[\e[0;31m\]"
    local -r COLOR_RED_BOLD="\[\e[1;31m\]"
    local -r COLOR_GREEN="\[\e[0;32m\]"
    local -r COLOR_GREEN_BOLD="\[\e[1;32m\]"
    local -r COLOR_MAGENTA="\[\e[0;35m\]"
    local -r COLOR_MAGENTA_BOLD="\[\e[1;35m\]"
    local -r COLOR_BLUE_BOLD="\[\e[1;34m\]"
    local -r COLOR_GRAY_BOLD="\[\e[1;30m\]"
    local -r TAB="\011"

    function trim() {
        echo -e "$(echo -e "$@" | \
            sed -e 's/[[:space:]]*$//' | \
            sed -e 's/^[[:space:]]*//')"
    }

    function stripNonPrintable() {
        echo -e "$@" | \
            sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" | \
            sed -r "s/\\\[][\]//g"
    }

    function isRoot() {
        [[ "${USER}" == *"root" ]] \
            && return 0 \
            || return 1
    }

    function pwd() {
        local dir="$PWD"
        [[ "$dir" =~ ^"$HOME"(/|$) ]] && dir="~${dir#$HOME}"
        [[ "$dir" = "~/" ]] && dir="~"
        echo "$dir"
    }

    function userAtHost() {
        local userhost="$USER@$HOSTNAME"
        userhost="$(trim $userhost)"
        # Only show username/host if not default
        [ "$userhost" = "$PROMPT_DEFAULT_USERHOST" -a ! "$SSH_CONNECTION" -a ! "$SUDO_USER" ] \
            && ! isRoot \
            && return;

        if isRoot; then
            userhost="$COLOR_RED_BOLD$userhost"
        else
            userhost="$COLOR_GREEN_BOLD$userhost"
        fi

        echo $userhost;
    }

    function debianChroot() {
        local chroot=""
        if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
            chroot=$(cat /etc/debian_chroot)
            if isRoot; then
                chroot="$COLOR_RED_BOLD$chroot"
            else
                chroot="$COLOR_GREEN_BOLD$chroot"
            fi
        fi
        echo $chroot
    }

    function gitStatus() {
        local result
        local branchName
        local gitDir="$(git rev-parse --git-dir)"
        local dirty=""
        local timeout=""
        # Check if we're in a git repo
        git rev-parse --is-inside-work-tree &>/dev/null || return

        # Check what branch we're on
        if [ "$(find $gitDir/refs/heads -type f | wc -l)" = "0" ]; then
            # workaround for error messages in freshly initialized repo
            branchName="master(new)"
        else
            branchName="$(\
                git symbolic-ref --quiet --short HEAD 2>/dev/null || \
                git describe --all --exact-match HEAD 2>/dev/null || \
                git rev-parse --short HEAD 2>/dev/null || \
                echo '(unknown)' \
            )";
            branchName="$(trim ${branchName})"
        fi

        # Check if the current directory is in .git before running git checks
        if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then
            # Ensure the index is up to date.
            # git update-index --really-refresh -q &>/dev/null;

            # Check uncommited changes (slow)
            dirty+="$(timeout $PROMPT_GIT_TIMEOUT sh -c "\
                git diff-index --cached --quiet HEAD --ignore-submodules 2>/dev/null || \
                echo \~ \
            ")"
            [ $? -gt 0 ] && timeout+="~"

            # Check unindexed files (slow)
            dirty+="$(timeout $PROMPT_GIT_TIMEOUT sh -c "\
                git diff --no-ext-diff --quiet --ignore-submodules --exit-code || \
                echo \* \
            ")"
            [ $? -gt 0 ] && timeout+="*"

            # Check for untracked files
            dirty+="$(timeout $PROMPT_GIT_TIMEOUT sh -c "\
                [ -z \"$(git ls-files . --exclude-standard --others)\" ] || \
                echo + \
            ")"
            [ $? -gt 0 ] && timeout+="+"

            # Check for stashed changes
            dirty+="$(timeout $PROMPT_GIT_TIMEOUT sh -c "\
                [ -z \"$(git stash list)\" ] || \
                echo ^ \
            ")"
            [ $? -gt 0 ] && timeout+="^"

            [ "$timeout" ] && dirty+="($timeout)"
        else
            dirty="@git"
        fi

        result="[$branchName$dirty]"
        if [ "$dirty" ]; then
            result="$COLOR_MAGENTA_BOLD$result"
        else
            result="$COLOR_MAGENTA$result"
        fi

        echo "$result";
    }

    function terminalTitle() {
        local title=""
        title+="$(debianChroot)"
        title+="$(userAtHost)"
        title+="${title:+: }"
        title="$(stripNonPrintable $title)"
        title+="$(pwd)"
        [ "$@" ] && title+=" $(stripNonPrintable $@)"
        title="\[\e]0;$title\007\]"
        echo "$title"
    }

    function timestamp() {
        local ts=""
        if [ "$PROMPT_TIMESTAMP" = "0" ]; then
            ts=""
        elif [ "$PROMPT_TIMESTAMP" = "1" ]; then
            ts="$(date +"%T.%3N")"
        elif [ "$PROMPT_TIMESTAMP" = "2" ]; then
            ts="$(date +"%T")"
        elif [ "$PROMPT_TIMESTAMP" = "3" ]; then
            ts="$(date +"%F %T")"
        elif [ "$PROMPT_TIMESTAMP" = "4" ]; then
            ts="$(date +"%F %T.%3N")"
        elif [ ! -z "$PROMPT_TIMESTAMP" ]; then
            ts="$(date +"$PROMPT_TIMESTAMP")"
        fi

        if [ ! -z "$ts" ]; then
            echo "$COLOR_GRAY_BOLD[$ts]"
        fi
    }

    function cmdStatus() {
        [ $PROMPT_STATUS -eq 0 ] && return;
        local status="";
        status+="if [ ! \$? -o \$? -eq 0 ]; then "
        status+="echo \"$COLOR_GREEN+\"; "
        status+="else "
        status+="echo \"$COLOR_RED-\"; "
        status+="fi"
        status="\$($status)"
        echo $status
    }

    function buildPS1() {
        local gitStatus="$(gitStatus)"
        local PS1=""
        PS1+="$(debianChroot)"
        PS1+="$(userAtHost)"
        PS1+="${PS1:+$COLOR_RESET:}"
        PS1+="$COLOR_BLUE_BOLD$(pwd)"
        PS1+="${gitStatus:+$gitStatus}"
        PS1+="$COLOR_RESET"
        if [ $PROMPT_NEWLINE -gt -1 -a $(stripNonPrintable "$PS1" | wc -c) -gt $PROMPT_NEWLINE ]; then
            PS1+="\n"
        fi
        PS1+="\$ "
        PS1="$(cmdStatus)$(timestamp)$PS1"
        if [ $PROMPT_COLORS -eq 0 ]; then
            PS1="$(stripNonPrintable "$PS1")"
        fi
        PS1="$(terminalTitle "$gitStatus")$PS1"
        echo "$PS1";
    }

    function buildPS4() {
        local PS4="+ ";
        PS4+="$COLOR_GRAY_BOLD\$(date +"%T.%3N") "
        PS4+="$COLOR_BLUE_BOLD\${BASH_SOURCE}$COLOR_RESET:\e[1;36m\$LINENO"
        PS4+="$COLOR_RESET$TAB\${FUNCNAME[0]:+$COLOR_MAGENTA\${FUNCNAME[0]}$COLOR_GRAY_BOLD()$COLOR_RESET:$TAB }"
        if [ $PROMPT_COLORS -eq 0 ]; then
            PS4="$(stripNonPrintable "$PS4")"
        fi
        echo "$PS4";
    }

    if [ $PROMPT_SIMPLE -eq 1 ]; then
        if [ ! $PROMPT_COLORS -eq 0 ]; then
            export PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
        else
            export PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
        fi
        export PS2="> "
        export PS4="+ "
    else
        export PS1="$(buildPS1)"    # Prompt string
        export PS2="âš¡ "             # Subshell prompt string
        export PS4="$(buildPS4)"    # Debug prompt string  (when using `set -x`)
    fi

}

export PROMPT_COMMAND=PROMPT_COMMAND
