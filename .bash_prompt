#!/bin/bash

# This prompt inspired by:
#   https://github.com/alrra/dotfiles/blob/master/shell/bash_prompt
#   https://github.com/paulirish/dotfiles/blob/master/.bash_prompt
#   https://github.com/mathiasbynens/dotfiles/blob/master/.bash_prompt

# Documentation:
#   http://www.thegeekstuff.com/2008/09/bash-shell-take-control-of-ps1-ps2-ps3-ps4-and-prompt_command/
#   http://askubuntu.com/questions/372849/what-does-debian-chrootdebian-chroot-do-in-my-terminal-prompt
#   http://misc.flogisoft.com/bash/tip_colors_and_formatting
#   http://wiki.bash-hackers.org/scripting/terminalcodes

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM=xterm-256color
fi

# Config
declare PROMPT_DEFAULT_USERHOST=""      # Add it to ~/.bash_exports_local
declare PROMPT_GIT_TIMEOUT="0.5s"       # Git status check timeout
declare PROMPT_TIMESTAMP="0"            # Add timestamp to prompt (date format)
declare -i PROMPT_NEWLINE=40            # Break command line after 40 characters (-1=never)
declare -i PROMPT_COLORS=1              # Use colors
declare -i PROMPT_STATUS=0              # Show last command result status
declare -i PROMPT_SIMPLE=0              # Fallback to simple prompt

function PROMPT_COMMAND() {
    local -r COLOR_RESET="\[\e[0m\]"
    local -r COLOR_RED="\[\e[0;31m\]"
    local -r COLOR_RED_BOLD="\[\e[1;31m\]"
    local -r COLOR_GREEN="\[\e[0;32m\]"
    local -r COLOR_GREEN_BOLD="\[\e[1;32m\]"
    local -r COLOR_MAGENTA="\[\e[0;35m\]"
    local -r COLOR_MAGENTA_BOLD="\[\e[1;35m\]"
    local -r COLOR_BLUE_BOLD="\[\e[1;34m\]"
    local -r COLOR_GRAY_BOLD="\[\e[1;30m\]"
    local -r TAB="\011"

    function trim() {
        echo -e "$(echo -e "$@" | \
            sed -e 's/[[:space:]]*$//' | \
            sed -e 's/^[[:space:]]*//')"
    }

    function stripNonPrintable() {
        echo -e "$@" | \
            sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" | \
            sed -r "s/\\\[][\]//g"
    }

    function isRoot() {
        [[ "${USER}" == *"root" ]] \
            && return 0 \
            || return 1
    }

    function pwd() {
        local dir="$PWD"
        [[ "$dir" =~ ^"$HOME"(/|$) ]] && dir="~${dir#$HOME}"
        [[ "$dir" = "~/" ]] && dir="~"
        echo "$dir"
    }

    function userAtHost() {
        local userhost="$USER@$HOSTNAME"
        userhost="$(trim $userhost)"
        # Only show username/host if not default
        [ "$userhost" = "$PROMPT_DEFAULT_USERHOST" -a ! "$SSH_CONNECTION" -a ! "$SUDO_USER" ] \
            && ! isRoot \
            && return;

        if isRoot; then
            userhost="$COLOR_RED_BOLD$userhost"
        else
            userhost="$COLOR_GREEN_BOLD$userhost"
        fi

        echo $userhost;
    }

    function debianChroot() {
        local chroot=""
        if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
            chroot=$(cat /etc/debian_chroot)
            if isRoot; then
                chroot="$COLOR_RED_BOLD$chroot"
            else
                chroot="$COLOR_GREEN_BOLD$chroot"
            fi
        fi
        echo $chroot
    }

    function gitStatus() {
        # check if we're in a git repo. (fast)
        git rev-parse --is-inside-work-tree &>/dev/null || return

        # check for what branch we're on. (fast)
        #   if HEAD isn’t a symbolic ref (typical branch),
        #   then get a tracking remote branch or tag
        #   otherwise get the short SHA for the latest commit
        #   lastly just give up.
        local branchName="$(\
            git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git describe --all --exact-match HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo '(unknown)' \
        )";
        branchName="$(trim ${branchName})"
        local gitStatus="$branchName"

        ## check uncommited
        local uncommitted="$(timeout $PROMPT_GIT_TIMEOUT sh -c "\
            git diff-index --cached --quiet HEAD --ignore-submodules || \
            echo \~ \
        ")"
        [ $? -gt 0 ] && uncommitted="?" # timouted

        ## check unindexed
        local unindexed="";
        unindexed="$(timeout $PROMPT_GIT_TIMEOUT sh -c "\
            git diff --no-ext-diff --quiet --ignore-submodules --exit-code || \
            echo \* \
        ")"
        [ $? -gt 0 ] && unindexed="?" # timouted

        ## check untracked
        local untracked="";
        untracked="$(timeout $PROMPT_GIT_TIMEOUT sh -c "\
            [ -z \"$(git ls-files . --exclude-standard --others)\" ] || \
            echo + \
        ")"
        [ $? -gt 0 ] && untracked="?" # timouted

        if [ "$uncommitted" = "?" -o "$unindexed" = "?" -o "$untracked" = "?" ]; then
            [ -z "$uncommitted" ] && [[ "$untracked$unindexed" == *"?" ]] && uncommitted="_";
            [ -z "$unindexed" ] && [ "$untracked" = "?" ] && unindexed="_";
            # [ -z "$untracked" ] && untracked="_";
        fi
        gitStatus="$gitStatus$uncommitted$unindexed$untracked"
        gitStatus="[$gitStatus]"
        if [ "$untracked" -o "$unindexed" -o "$uncommitted" ]; then
            gitStatus="$COLOR_MAGENTA_BOLD$gitStatus"
        else
            gitStatus="$COLOR_MAGENTA$gitStatus"
        fi
        echo "$gitStatus";
    }

    function terminalTitle() {
        local title=""
        title+="$(debianChroot)"
        title+="$(userAtHost)"
        title+="${title:+: }"
        title="$(stripNonPrintable $title)"
        title+="$(pwd)"
        if [ "$@" ]; then
            title+=" $(stripNonPrintable $@)"
        fi
        title="\[\e]0;$title\007\]"
        echo "$title"
    }

    function timestamp() {
        local ts=""
        if [ "$PROMPT_TIMESTAMP" = "0" ]; then
            ts=""
        elif [ "$PROMPT_TIMESTAMP" = "1" ]; then
            ts="$(date +"%T.%3N")"
        elif [ "$PROMPT_TIMESTAMP" = "2" ]; then
            ts="$(date +"%T")"
        elif [ "$PROMPT_TIMESTAMP" = "3" ]; then
            ts="$(date +"%F %T")"
        elif [ "$PROMPT_TIMESTAMP" = "4" ]; then
            ts="$(date +"%F %T.%3N")"
        elif [ ! -z "$PROMPT_TIMESTAMP" ]; then
            ts="$(date +"$PROMPT_TIMESTAMP")"
        fi

        if [ ! -z "$ts" ]; then
            echo "$COLOR_GRAY_BOLD[$ts]"
        fi
    }

    function cmdStatus() {
        if [ $PROMPT_STATUS -eq 0 ]; then
            return;
        fi;
        local status="";
        status+="if [ ! \$? -o \$? -eq 0 ]; then "
        status+="echo \"$COLOR_GREEN+\"; "
        status+="else "
        status+="echo \"$COLOR_RED-\"; "
        status+="fi"
        status="\$($status)"
        echo $status
    }

    function buildPS1() {
        local gitStatus="$(gitStatus)"
        local PS1=""
        PS1+="$(debianChroot)"
        PS1+="$(userAtHost)"
        PS1+="${PS1:+$COLOR_RESET:}"
        PS1+="$COLOR_BLUE_BOLD$(pwd)"
        PS1+="${gitStatus:+$gitStatus}"
        PS1+="$COLOR_RESET"
        if [ $PROMPT_NEWLINE -gt -1 -a $(stripNonPrintable "$PS1" | wc -c) -gt $PROMPT_NEWLINE ]; then
            PS1+="\n"
        fi
        PS1+="\$ "
        PS1="$(cmdStatus)$(timestamp)$PS1"
        if [ $PROMPT_COLORS -eq 0 ]; then
            PS1="$(stripNonPrintable "$PS1")"
        fi
        PS1="$(terminalTitle "$gitStatus")$PS1"
        echo "$PS1";
    }

    function buildPS4() {
        local PS4="+ ";
        PS4+="$COLOR_GRAY_BOLD\$(date +"%T.%3N") "
        PS4+="$COLOR_BLUE_BOLD\${BASH_SOURCE}$COLOR_RESET:\e[1;36m\$LINENO"
        PS4+="$COLOR_RESET$TAB\${FUNCNAME[0]:+$COLOR_MAGENTA\${FUNCNAME[0]}$COLOR_GRAY_BOLD()$COLOR_RESET:$TAB }"
        if [ $PROMPT_COLORS -eq 0 ]; then
            PS4="$(stripNonPrintable "$PS4")"
        fi
        echo "$PS4";
    }

    if [ $PROMPT_SIMPLE -eq 1 ]; then
        if [ ! $PROMPT_COLORS -eq 0 ]; then
            export PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
        else
            export PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
        fi
        export PS2="> "
        export PS4="+ "
    else
        export PS1="$(buildPS1)"    # Prompt string
        export PS2="⚡ "             # Subshell prompt string
        export PS4="$(buildPS4)"    # Debug prompt string  (when using `set -x`)
    fi

}

export PROMPT_COMMAND=PROMPT_COMMAND
